<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>슈퍼 코코넛 어드벤처</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Press Start 2P', cursive;
        }
        #game-container {
            box-shadow: 0 20px 80px rgba(0,0,0,0.8);
            border-radius: 15px;
            overflow: hidden;
            border: 6px solid #ffd700;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // 전역 변수
        let player, cursors, platforms, coins, enemies, goal, questionBlocks, movingPlatforms, powerups, spikes, springs, fireballs;
        let score = 0;
        let lives = 3;
        let currentLevel = 1;
        let scoreText, livesText, levelText, timerText;
        let gameOver = false;
        let sounds = {};
        let levelTime = 0;
        let timeBonus = 1000;
        let wingL, wingR;
        let shootKey;

        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 900 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        function preload() {}

        function create() {
            if (wingL) wingL.destroy();
            if (wingR) wingR.destroy();
            wingL = null;
            wingR = null;

            // 사운드 초기화
            if (Object.keys(sounds).length === 0) {
                sounds.jump = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).toDestination();
                sounds.superJump = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                sounds.coin = new Tone.PolySynth(Tone.Synth).toDestination();
                sounds.stomp = new Tone.PluckSynth().toDestination();
                sounds.death = new Tone.MembraneSynth().toDestination();
                sounds.win = new Tone.Synth({ oscillator: { type: "square" } }).toDestination();
                sounds.powerup = new Tone.Synth({ oscillator: { type: "square" } }).toDestination();
                sounds.blockHit = new Tone.MetalSynth().toDestination();
                sounds.spring = new Tone.Synth({ oscillator: { type: "sine" } }).toDestination();
                sounds.shoot = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
                sounds.enemyFireHit = new Tone.Synth({ oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1 } }).toDestination();
                
                this.input.on('pointerdown', () => {
                    if (Tone.context.state !== 'running') Tone.context.resume();
                }, this);
            }

            const worldWidth = 4000 + (currentLevel * 1000);
            levelTime = 0;

            const bgColors = [0x5c94fc, 0x9b59b6, 0x2c3e50, 0xc0392b, 0x1a1a2e];
            const bgColor = bgColors[currentLevel - 1] || bgColors[4];
            this.add.rectangle(450, 300, 900, 600, bgColor).setScrollFactor(0);
            
            for (let i = 0; i < 25; i++) {
                if (currentLevel <= 2) {
                    this.add.ellipse(Phaser.Math.Between(50, worldWidth), Phaser.Math.Between(50, 200), 
                        Phaser.Math.Between(100, 150), Phaser.Math.Between(50, 80), 0xffffff, 0.8);
                } else {
                    this.add.star(Phaser.Math.Between(50, worldWidth), Phaser.Math.Between(50, 250), 5, 3, 6, 0xffffff);
                }
            }

            this.physics.world.setBounds(0, 0, worldWidth, 600);

            platforms = this.physics.add.staticGroup();
            movingPlatforms = this.physics.add.group({ allowGravity: false, immovable: true });
            questionBlocks = this.physics.add.staticGroup();
            coins = this.physics.add.group();
            enemies = this.physics.add.group();
            powerups = this.physics.add.group();
            spikes = this.physics.add.staticGroup();
            springs = this.physics.add.staticGroup();
            goal = this.physics.add.staticGroup();
            fireballs = this.physics.add.group({ allowGravity: true });

            this.add.rectangle(0, 580, worldWidth, 40, 0x20bf6b).setOrigin(0);
            platforms.create(worldWidth / 2, 585, null).setDisplaySize(worldWidth, 30).setBodySize(worldWidth, 30).refreshBody().setVisible(false);

            createLevelMap(this, worldWidth, currentLevel);

            const goalX = worldWidth - 150;
            goal.create(goalX, 510, null).setSize(60, 120).setVisible(false);
            this.add.rectangle(goalX, 510, 100, 120, 0xffd700);
            this.add.star(goalX, 450, 5, 20, 40, 0xff6b6b).setOrigin(0.5);
            this.add.text(goalX, 520, 'GOAL', { fontSize: '20px', fill: '#000', fontStyle: 'bold' }).setOrigin(0.5);

            player = this.physics.add.sprite(100, 500, createCoconutPlayerTexture(this));
            player.setBounce(0.1);
            player.setCollideWorldBounds(true);
            player.body.setCircle(20);
            player.isInvincible = false;
            player.canDoubleJump = false;
            player.hasDoubleJumped = false;
            player.canShootFire = false;

            this.cameras.main.setBounds(0, 0, worldWidth, 600);
            this.cameras.main.startFollow(player, true, 0.1, 0.1);

            scoreText = this.add.text(16, 16, `점수: ${score}`, { fontSize: '20px', fill: '#fff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setScrollFactor(0);
            livesText = this.add.text(16, 46, `❤️ x ${lives}`, { fontSize: '20px', fill: '#ff0000', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setScrollFactor(0);
            levelText = this.add.text(16, 76, `레벨: ${currentLevel}`, { fontSize: '20px', fill: '#ffd700', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setScrollFactor(0);
            timerText = this.add.text(750, 16, `시간: 0`, { fontSize: '20px', fill: '#fff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setScrollFactor(0);

            // 충돌 설정
            this.physics.add.collider(player, platforms);
            this.physics.add.collider(player, movingPlatforms);
            this.physics.add.collider(player, questionBlocks, hitQuestionBlock, null, this);
            this.physics.add.collider(coins, platforms);
            this.physics.add.collider(coins, movingPlatforms);
            this.physics.add.collider(enemies, platforms);
            this.physics.add.collider(enemies, movingPlatforms);
            this.physics.add.overlap(player, coins, collectCoin, null, this);
            this.physics.add.collider(player, enemies, hitEnemy, null, this);
            this.physics.add.overlap(player, powerups, collectPowerup, null, this);
            this.physics.add.overlap(player, spikes, hitSpike, null, this);
            this.physics.add.overlap(player, springs, hitSpring, null, this);
            this.physics.add.collider(player, goal, reachGoal, null, this);
            this.physics.add.collider(fireballs, platforms, (fireball) => fireball.destroy());
            this.physics.add.collider(fireballs, movingPlatforms, (fireball) => fireball.destroy());
            this.physics.add.overlap(fireballs, enemies, hitEnemyWithFireball, null, this);

            cursors = this.input.keyboard.createCursorKeys();
            this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            shootKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
        }

        function update(time, delta) {
            if (gameOver || !player.active) {
                if (player.active) player.setVelocity(0, 0);
                return;
            }

            levelTime += delta / 1000;
            timerText.setText(`시간: ${Math.floor(levelTime)}`);

            const moveSpeed = 250;
            if (cursors.left.isDown) {
                player.setVelocityX(-moveSpeed);
                player.setFlipX(true);
            } else if (cursors.right.isDown) {
                player.setVelocityX(moveSpeed);
                player.setFlipX(false);
            } else {
                player.setVelocityX(0);
            }
            
            const onGround = player.body.touching.down;
            if (onGround) {
                player.hasDoubleJumped = false;
            }

            if (Phaser.Input.Keyboard.JustDown(cursors.up) || Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                if (onGround) {
                    player.setVelocityY(-520);
                    sounds.jump.triggerAttackRelease("C5", "8n");
                } else if (player.canDoubleJump && !player.hasDoubleJumped) {
                    player.setVelocityY(-520);
                    player.hasDoubleJumped = true;
                    sounds.superJump.triggerAttackRelease("G5", "8n");
                    const circle = this.add.circle(player.x, player.y, 30, 0x00ff00, 0.5);
                    this.tweens.add({ targets: circle, scale: 2, alpha: 0, duration: 300, onComplete: () => circle.destroy() });
                }
            }
            
            if (Phaser.Input.Keyboard.JustDown(shootKey) && player.canShootFire) {
                shootFireball(this);
            }

            if (player.canDoubleJump && wingL && wingR) {
                wingL.setPosition(player.x - 20, player.y - 5);
                wingR.setPosition(player.x + 20, player.y - 5);
                const flap = Math.sin(time / 150) * 15;
                wingL.setAngle(flap);
                wingR.setAngle(flap);
            }
            
            movingPlatforms.children.iterate(p => {
                if (p.active) {
                    const speed = p.moveSpeed || 100;
                    if (p.moveType === 0) {
                        if (p.x <= p.moveStart) p.setVelocityX(speed);
                        if (p.x >= p.moveStart + p.moveRange) p.setVelocityX(-speed);
                    } else if (p.moveType === 1) {
                        if (p.y <= p.moveStart) p.setVelocityY(speed);
                        if (p.y >= p.moveStart + p.moveRange) p.setVelocityY(-speed);
                    }
                }
            });

            enemies.children.iterate(e => {
                if (e && e.active && e.patrolBounds) {
                    if (e.x < e.patrolBounds.start) e.setVelocityX(Math.abs(e.body.velocity.x));
                    if (e.x > e.patrolBounds.end) e.setVelocityX(-Math.abs(e.body.velocity.x));
                }
            });

            if (player.y > this.physics.world.bounds.height + 50) handlePlayerDeath(this);
        }

        function createLevelMap(scene, worldWidth, level) {
            const createStaticPlatform = (x, y, width, height) => {
                const platform = platforms.create(x, y);
                platform.setTexture(createBrickTexture(scene, width, height));
                platform.setDisplaySize(width, height);
                platform.refreshBody();
            };

            // 레벨 1: 초급
            if (level === 1) {
                [[400, 500, 80, 30], [700, 450, 80, 30], [1000, 400, 80, 30], [1400, 480, 80, 30], [1800, 420, 80, 30], [2200, 380, 80, 30], 
                 [2600, 440, 80, 30], [3000, 400, 80, 30], [3400, 460, 80, 30], [3800, 420, 80, 30], [4200, 480, 80, 30], [4600, 440, 80, 30]].forEach(p => {
                    createStaticPlatform(p[0], p[1], p[2], p[3]);
                });

                [[500, 450, 'coins'], [1200, 350, 'star'], [2000, 370, 'fireFlower'], 
                 [2800, 390, 'doubleJump'], [3600, 410, 'coins'], [4400, 430, 'star']].forEach(b => {
                    const block = questionBlocks.create(b[0], b[1], createQuestionBlockTexture(scene)).refreshBody();
                    block.body.setSize(40, 40);
                    block.rewardType = b[2];
                });

                [[1100, 470, 0, 250, 100], [2500, 350, 1, 180, 100], [3900, 440, 0, 300, 100]].forEach(p => {
                    const platform = movingPlatforms.create(p[0], p[1], createBrickTexture(scene, 120, 25));
                    platform.body.setSize(120, 25);
                    platform.moveType = p[2]; platform.moveRange = p[3]; platform.moveSpeed = p[4];
                    platform.moveStart = p[2] === 0 ? p[0] : p[1];
                    platform.setVelocity(p[2] === 0 ? p[4] : 0, p[2] === 1 ? p[4] : 0);
                });
                [1500, 3000, 4500].forEach(x => springs.create(x, 560, createSpringTexture(scene)).refreshBody());
            }
            // 레벨 2: 중급
            else if (level === 2) {
                [[300, 500, 70, 25], [600, 450, 70, 25], [900, 380, 70, 25], [1300, 320, 70, 25], [1700, 400, 70, 25], [2100, 320, 70, 25], [2500, 380, 70, 25], [2900, 300, 70, 25], [3300, 380, 70, 25], [3700, 440, 70, 25], [4100, 360, 70, 25], [4500, 420, 70, 25], [4900, 340, 70, 25], [5300, 400, 70, 25]].forEach(p => {
                    createStaticPlatform(p[0], p[1], p[2], p[3]);
                });
                [[700, 400, 'star'], [1400, 270, 'doubleJump'], [2200, 270, 'coins'], [3000, 250, 'fireFlower'], [3800, 390, 'coins'], [4600, 370, 'doubleJump'], [5400, 350, 'star']].forEach(b => {
                    const block = questionBlocks.create(b[0], b[1], createQuestionBlockTexture(scene)).refreshBody();
                    block.body.setSize(40, 40); block.rewardType = b[2];
                });
                [[1000, 450, 0, 200, 120], [1900, 350, 1, 150, 120], [2700, 300, 0, 250, 120], [3500, 400, 1, 180, 120], [4300, 360, 0, 220, 120], [5100, 420, 1, 160, 120]].forEach(p => {
                    const platform = movingPlatforms.create(p[0], p[1], createBrickTexture(scene, 100, 20));
                    platform.body.setSize(100, 20); platform.moveType = p[2]; platform.moveRange = p[3]; platform.moveSpeed = p[4];
                    platform.moveStart = p[2] === 0 ? p[0] : p[1];
                    platform.setVelocity(p[2] === 0 ? p[4] : 0, p[2] === 1 ? p[4] : 0);
                });
                [[1200, 570], [2400, 570], [3600, 570], [4800, 570]].forEach(pos => {
                    for (let i = 0; i < 3; i++) spikes.create(pos[0] + i * 40, pos[1], createSpikeTexture(scene)).refreshBody();
                });
                [800, 2200, 3800, 5200].forEach(x => springs.create(x, 560, createSpringTexture(scene)).refreshBody());
            }
            // Other levels follow the same pattern...
            else if (level === 3) {
                 [[250, 520, 60, 20], [500, 460, 60, 20], [750, 380, 60, 20], [1050, 300, 60, 20], [1400, 240, 60, 20], [1750, 320, 60, 20], [2100, 260, 60, 20], [2450, 340, 60, 20], [2800, 280, 60, 20], [3150, 360, 60, 20], [3500, 300, 60, 20], [3850, 380, 60, 20], [4200, 320, 60, 20], [4550, 400, 60, 20], [4900, 340, 60, 20], [5250, 420, 60, 20], [5600, 360, 60, 20], [5950, 440, 60, 20]].forEach(p => {
                    createStaticPlatform(p[0], p[1], p[2], p[3]);
                });
                 [[600, 410, 'doubleJump'], [1150, 250, 'star'], [1850, 270, 'fireFlower'], [2550, 290, 'star'], [3250, 310, 'coins'], [3950, 330, 'doubleJump'], [4650, 350, 'star'], [5350, 370, 'coins']].forEach(b => {
                    const block = questionBlocks.create(b[0], b[1], createQuestionBlockTexture(scene)).refreshBody();
                    block.body.setSize(40, 40); block.rewardType = b[2];
                });
                 [[900, 430, 0, 180, 150], [1550, 320, 1, 120, 150], [2250, 340, 0, 200, 150], [2950, 280, 1, 140, 150], [3650, 380, 0, 220, 150], [4350, 320, 1, 160, 150], [5050, 390, 0, 200, 150], [5750, 360, 1, 140, 150]].forEach(p => {
                    const platform = movingPlatforms.create(p[0], p[1], createBrickTexture(scene, 80, 18));
                    platform.body.setSize(80, 18); platform.moveType = p[2]; platform.moveRange = p[3]; platform.moveSpeed = p[4];
                    platform.moveStart = p[2] === 0 ? p[0] : p[1];
                    platform.setVelocity(p[2] === 0 ? p[4] : 0, p[2] === 1 ? p[4] : 0);
                });
                [[800, 570], [1400, 570], [2000, 570], [2600, 570], [3200, 570], [3800, 570], [4400, 570], [5000, 570], [5600, 570]].forEach(pos => {
                    for (let i = 0; i < 4; i++) spikes.create(pos[0] + i * 35, pos[1], createSpikeTexture(scene)).refreshBody();
                });
                [1100, 2300, 3500, 4700, 5900].forEach(x => springs.create(x, 560, createSpringTexture(scene)).refreshBody());
            }
            else if (level === 4) {
                 [[250, 520, 55, 18], [500, 460, 55, 18], [800, 400, 55, 18], [1150, 350, 55, 18], [1500, 400, 55, 18], [1850, 320, 55, 18], [2200, 260, 55, 18], [2550, 340, 55, 18], [2900, 400, 55, 18], [3250, 360, 55, 18], [3600, 300, 55, 18], [3950, 380, 55, 18], [4300, 320, 55, 18], [4650, 400, 55, 18], [5000, 340, 55, 18], [5350, 420, 55, 18], [5700, 360, 55, 18], [6050, 440, 55, 18], [6400, 380, 55, 18], [6750, 320, 55, 18]].forEach(p => {
                    createStaticPlatform(p[0], p[1], p[2], p[3]);
                });
                 [[900, 300, 'doubleJump'], [1600, 250, 'star'], [2800, 300, 'fireFlower'], [4000, 280, 'doubleJump'], [5100, 250, 'star'], [6200, 300, 'coins']].forEach(b => {
                    const block = questionBlocks.create(b[0], b[1], createQuestionBlockTexture(scene)).refreshBody();
                    block.body.setSize(40, 40); block.rewardType = b[2];
                });
                 [[700, 480, 0, 180, 170], [1300, 300, 1, 150, 170], [1950, 400, 0, 200, 170], [2400, 200, 1, 100, 170], [3100, 450, 0, 250, 170], [3750, 250, 1, 180, 170], [4450, 420, 0, 220, 170], [4800, 220, 1, 120, 170], [5500, 500, 0, 300, 170], [6000, 280, 1, 150, 170], [6500, 400, 0, 200, 170]].forEach(p => {
                    const platform = movingPlatforms.create(p[0], p[1], createBrickTexture(scene, 80, 18));
                    platform.body.setSize(80, 18); platform.moveType = p[2]; platform.moveRange = p[3]; platform.moveSpeed = p[4];
                    platform.moveStart = p[2] === 0 ? p[0] : p[1];
                    platform.setVelocity(p[2] === 0 ? p[4] : 0, p[2] === 1 ? p[4] : 0);
                });
                [800, 1400, 2000, 2600, 3200, 3800, 4400, 5000, 5600, 6200, 6800].forEach(x => {
                    for (let i = 0; i < 5; i++) spikes.create(x + i * 35, 570, createSpikeTexture(scene)).refreshBody();
                });
                [1200, 2800, 4500, 6500].forEach(x => springs.create(x, 560, createSpringTexture(scene)).refreshBody());
            }
            else if (level === 5) {
                [[200, 500, 50, 15], [450, 450, 50, 15], [800, 400, 50, 15], [1200, 350, 50, 15], [1650, 300, 50, 15], [2100, 380, 50, 15], [2600, 320, 50, 15], [3100, 280, 50, 15], [3600, 340, 50, 15], [4100, 400, 50, 15], [4600, 360, 50, 15], [5100, 300, 50, 15], [5600, 380, 50, 15], [6100, 440, 50, 15], [6600, 380, 50, 15], [7100, 320, 50, 15], [7600, 400, 50, 15]].forEach(p => {
                    createStaticPlatform(p[0], p[1], p[2], p[3]);
                });
                [[1000, 250, 'doubleJump'], [3300, 200, 'star'], [5500, 250, 'fireFlower'], [6800, 280, 'coins']].forEach(b => {
                    const block = questionBlocks.create(b[0], b[1], createQuestionBlockTexture(scene)).refreshBody();
                    block.body.setSize(40, 40); block.rewardType = b[2];
                });
                 [[600, 400, 0, 150, 200], [1400, 250, 1, 180, 200], [1900, 450, 0, 220, 200], [2350, 200, 1, 100, 200], [2850, 480, 0, 280, 200], [3800, 220, 1, 150, 200], [4350, 420, 0, 250, 200], [4850, 200, 1, 130, 200], [5350, 500, 0, 320, 200], [5850, 280, 1, 160, 200], [6350, 450, 0, 250, 200], [7300, 250, 1, 200, 200]].forEach(p => {
                    const platform = movingPlatforms.create(p[0], p[1], createBrickTexture(scene, 70, 15));
                    platform.body.setSize(70, 15); platform.moveType = p[2]; platform.moveRange = p[3]; platform.moveSpeed = p[4];
                    platform.moveStart = p[2] === 0 ? p[0] : p[1];
                    platform.setVelocity(p[2] === 0 ? p[4] : 0, p[2] === 1 ? p[4] : 0);
                });
                const spikePositions = [600, 1000, 1400, 1800, 2200, 2600, 3000, 3400, 3800, 4200, 4600, 5000, 5400, 5800, 6200, 6600, 7000, 7400, 7800];
                spikePositions.forEach(x => {
                    for (let i = 0; i < 6; i++) spikes.create(x + i * 30, 570, createSpikeTexture(scene)).refreshBody();
                });
                spikes.create(2400, 150, createSpikeTexture(scene)).setAngle(180).refreshBody();
                spikes.create(2430, 150, createSpikeTexture(scene)).setAngle(180).refreshBody();
                spikes.create(4900, 150, createSpikeTexture(scene)).setAngle(180).refreshBody();
                spikes.create(4930, 150, createSpikeTexture(scene)).setAngle(180).refreshBody();
                [1500, 4000, 7500].forEach(x => springs.create(x, 560, createSpringTexture(scene)).refreshBody());
            }

            const coinTexture = createCoinTexture(scene);
            const coinCount = 15 + (level * 5);
            for (let i = 0; i < coinCount; i++) {
                const x = Phaser.Math.Between(300, worldWidth - 300);
                const y = Phaser.Math.Between(200, 500);
                coins.create(x, y, coinTexture).setBounceY(0.3);
            }

            const enemyTexture = createEnemyTexture(scene);
            const enemyCount = 8 + (level * 2);
            for (let i = 0; i < enemyCount; i++) {
                const x = Phaser.Math.Between(500, worldWidth - 500);
                const enemy = enemies.create(x, 530, enemyTexture);
                const patrolRange = 200 + (level * 50);
                enemy.setBounce(1).setCollideWorldBounds(true)
                    .setVelocityX(Phaser.Math.Between(80, 120 + level * 20) * (Math.random() > 0.5 ? 1 : -1));
                enemy.patrolBounds = { start: x - patrolRange, end: x + patrolRange };
                enemy.body.setSize(32, 32);
            }
        }

        function hitQuestionBlock(player, block) {
            if (gameOver || !block.active) return;
            if (player.body.touching.up && block.body.touching.down) {
                sounds.blockHit.triggerAttack("C4");
                block.setTexture(createBrickTexture(this, 40, 40));
                block.disableBody(true, false);

                let reward;
                if (block.rewardType === 'coins') {
                    for (let i = 0; i < 5; i++) {
                        const coin = coins.create(block.x, block.y - 30, createCoinTexture(this));
                        coin.setVelocity(Phaser.Math.Between(-50, 50), -300);
                    }
                } else if (block.rewardType === 'star') {
                    reward = powerups.create(block.x, block.y - 40, createStarTexture(this));
                    reward.powerType = 'invincible';
                } else if (block.rewardType === 'doubleJump') {
                    reward = powerups.create(block.x, block.y - 40, createWingTexture(this));
                    reward.powerType = 'doubleJump';
                } else if (block.rewardType === 'fireFlower') {
                    reward = powerups.create(block.x, block.y - 40, createFireFlowerTexture(this));
                    reward.powerType = 'fireFlower';
                }

                if(reward) {
                    reward.setVelocity(50, -200).setBounce(1).setCollideWorldBounds(true);
                }
                
                this.tweens.add({ targets: block, y: block.y - 10, duration: 100, yoyo: true });
            }
        }

        function collectPowerup(player, powerup) {
            if (gameOver) return;
            powerup.disableBody(true, true);

            sounds.powerup.triggerAttackRelease("C5", "0.1");
            this.time.delayedCall(100, () => sounds.powerup.triggerAttackRelease("E5", "0.1"));
            this.time.delayedCall(200, () => sounds.powerup.triggerAttackRelease("G5", "0.1"));

            if (powerup.powerType === 'invincible') {
                player.isInvincible = true;
                const invincibleTween = this.tweens.add({ targets: player, alpha: 0.5, duration: 150, yoyo: true, loop: 40 });
                this.time.delayedCall(12000, () => {
                    player.isInvincible = false;
                    if (player.active) { invincibleTween.stop(); player.setAlpha(1); }
                });
            } else if (powerup.powerType === 'doubleJump') {
                player.canDoubleJump = true;
                if (!wingL) {
                    wingL = this.add.triangle(0, 0, 0, 0, 20, 10, 0, 20, 0x00ff00, 0.9).setOrigin(0.5, 0.5);
                    wingR = this.add.triangle(0, 0, 0, 0, -20, 10, 0, 20, 0x00ff00, 0.9).setOrigin(0.5, 0.5);
                }
                this.time.delayedCall(15000, () => {
                    player.canDoubleJump = false;
                    if (wingL) { wingL.destroy(); wingL = null; }
                    if (wingR) { wingR.destroy(); wingR = null; }
                });
            } else if (powerup.powerType === 'fireFlower') {
                player.canShootFire = true;
                player.setTint(0xff8c00); // 주황색 틴트
                this.time.delayedCall(15000, () => {
                    if(player.active) {
                        player.canShootFire = false;
                        player.clearTint();
                    }
                });
            }
        }

        function hitEnemy(player, enemy) {
            if (gameOver || !player.active) return;

            // Case 1: Player is invincible (e.g., from a star)
            if (player.isInvincible) {
                enemy.disableBody(true, true);
                score += 100;
                scoreText.setText(`점수: ${score}`);
                sounds.stomp.triggerAttackRelease("C3", "8n");
                return;
            }

            // Case 2: Player stomps on the enemy
            // *** 오류 수정: y좌표 판정 조건을 -15에서 -10으로 완화 ***
            if (player.body.velocity.y > 0 && player.y < enemy.y - 10) {
                enemy.disableBody(true, true);
                player.setVelocityY(-300);
                score += 50;
                scoreText.setText(`점수: ${score}`);
                sounds.stomp.triggerAttackRelease("C3", "8n");
                return;
            }

            // Case 3: Player gets hit (is not invincible and did not stomp)
            if (player.canShootFire) {
                // Lose the fire power-up instead of a life
                player.canShootFire = false;
                player.clearTint();
                sounds.powerup.triggerAttackRelease("G3", "4n"); // Power-down sound

                // Grant temporary invincibility to prevent chain-hits
                player.isInvincible = true;
                this.tweens.add({
                    targets: player,
                    alpha: 0.5,
                    duration: 200,
                    yoyo: true,
                    repeat: 5, // Blink for a total of 2 seconds
                    onComplete: () => {
                        if (player.active) {
                            player.isInvincible = false;
                            player.setAlpha(1);
                        }
                    }
                });
            } else {
                // No power-ups, so the player dies
                handlePlayerDeath(this);
            }
        }

        function hitSpike(player, spike) {
            if (!player.isInvincible && player.active) {
                if(player.canShootFire) {
                    player.canShootFire = false;
                    player.clearTint();
                }
                handlePlayerDeath(this);
            }
        }
        
        function shootFireball(scene) {
            const fireball = fireballs.create(player.x, player.y, createFireballTexture(scene));
            if (!fireball) return;
            sounds.shoot.triggerAttack();
            fireball.body.setCircle(8);
            fireball.setBounce(1);
            fireball.setCollideWorldBounds(true);
            fireball.body.onWorldBounds = true; // 월드 경계에 닿으면 이벤트 발생
            fireball.body.world.on('worldbounds', (body) => {
                if (body.gameObject === fireball) {
                    fireball.destroy();
                }
            }, scene);

            const fireballSpeed = 400;
            const velocityX = player.flipX ? -fireballSpeed : fireballSpeed;
            fireball.setVelocity(velocityX, -200);
            
            scene.time.delayedCall(3000, () => {
                if(fireball.active) fireball.destroy();
            });
        }
        
        function hitEnemyWithFireball(fireball, enemy) {
            fireball.destroy();
            enemy.disableBody(true, true);
            score += 100;
            scoreText.setText(`점수: ${score}`);
            sounds.enemyFireHit.triggerAttackRelease("A4", "8n");
        }


        function hitSpring(player, spring) {
            if (player.body.touching.down) {
                player.setVelocityY(-700);
                sounds.spring.triggerAttackRelease("C6", "8n");
                this.tweens.add({ targets: spring, scaleY: 0.5, duration: 100, yoyo: true });
            }
        }

        function handlePlayerDeath(scene) {
            if (gameOver || !player.active || player.isInvincible) return;
            
            player.isInvincible = true;
            lives--;
            livesText.setText(`❤️ x ${lives}`);
            sounds.death.triggerAttackRelease("C2", "4n");

            player.canDoubleJump = false;
            player.canShootFire = false;
            player.clearTint();
            if (wingL) { wingL.destroy(); wingL = null; }
            if (wingR) { wingR.destroy(); wingR = null; }
            
            if (lives <= 0) {
                gameOver = true;
                player.setTint(0xff0000);
                player.setVelocity(0, -300);
                player.setCollideWorldBounds(false);
                scene.cameras.main.shake(400, 0.01);
                createEndScreen(scene, false, false);
            } else {
                player.setAlpha(0);
                scene.cameras.main.flash(300, 255, 0, 0);

                scene.time.delayedCall(500, () => {
                    player.setPosition(100, 500);
                    player.setVelocity(0, 0);
                    player.setAlpha(1);

                    const respawnTween = scene.tweens.add({ targets: player, alpha: 0.5, duration: 150, yoyo: true, loop: 10 });
                    scene.time.delayedCall(3000, () => {
                        if (player.active) {
                            player.isInvincible = false;
                            respawnTween.stop();
                            player.setAlpha(1);
                        }
                    });
                });
            }
        }

        function collectCoin(player, coin) {
            if (gameOver) return;
            coin.disableBody(true, true);
            score += 10;
            scoreText.setText(`점수: ${score}`);
            sounds.coin.triggerAttackRelease("E6", "8n");
        }

        function reachGoal(player, goal) {
            if (gameOver) return;
            gameOver = true;
            player.setVelocityX(0);
            
            const bonus = Math.max(0, Math.floor((timeBonus - levelTime * 10)));
            score += bonus;
            
            sounds.win.triggerAttackRelease("C5", "4n");
            this.time.delayedCall(100, () => sounds.win.triggerAttackRelease("E5", "4n"));
            this.time.delayedCall(200, () => sounds.win.triggerAttackRelease("G5", "4n"));
            
            createEndScreen(this, true, currentLevel < 5);
        }

        function createEndScreen(scene, isWin, hasNextLevel) {
            const centerX = scene.cameras.main.scrollX + scene.cameras.main.width / 2;
            const centerY = scene.cameras.main.scrollY + scene.cameras.main.height / 2;
            
            const text = isWin ? (hasNextLevel ? '스테이지 클리어!' : '게임 클리어!') : '게임 오버';
            const color = isWin ? '#ffd700' : '#ff0000';
            
            scene.add.text(centerX, centerY - 80, text, { fontSize: '48px', fill: color, fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5);
            scene.add.text(centerX, centerY - 20, `최종 점수: ${score}`, { fontSize: '28px', fill: '#fff', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);

            if (isWin && hasNextLevel) {
                const nextBtn = scene.add.text(centerX, centerY + 40, '다음 레벨 →', { fontSize: '24px', fill: '#00ff00', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setInteractive();
                nextBtn.on('pointerdown', () => { currentLevel++; gameOver = false; scene.scene.restart(); });
                nextBtn.on('pointerover', () => nextBtn.setFill('#ffff00'));
                nextBtn.on('pointerout', () => nextBtn.setFill('#00ff00'));
            }

            const restartBtn = scene.add.text(centerX, centerY + (hasNextLevel && isWin ? 90 : 50), '다시 시작', { fontSize: '20px', fill: '#fff', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setInteractive();
            restartBtn.on('pointerdown', () => {
                if (!isWin || !hasNextLevel) { currentLevel = 1; score = 0; lives = 3; }
                gameOver = false;
                scene.scene.restart();
            });
            restartBtn.on('pointerover', () => restartBtn.setFill('#ffff00'));
            restartBtn.on('pointerout', () => restartBtn.setFill('#ffffff'));
        }

        // 텍스처 생성 함수들
        function createCoconutPlayerTexture(scene) {
            const key = 'coconutPlayer';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 40, height: 40 }, false);
            g.fillStyle(0x6B4F3A); g.fillEllipse(20, 20, 40, 40);
            g.fillStyle(0xffffff); g.fillEllipse(13, 18, 12, 14); g.fillEllipse(27, 18, 12, 14);
            g.fillStyle(0x000000); g.fillCircle(14, 20, 5); g.fillCircle(26, 20, 5);
            g.fillStyle(0x2ecc71); g.fillTriangle(20, 0, 15, 8, 25, 8);
            g.generateTexture(key, 40, 40); g.destroy();
            return key;
        }

        function createCoinTexture(scene, size = 24) {
            const key = `coinTexture${size}`;
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: size, height: size }, false);
            g.fillStyle(0xffd700); g.fillCircle(size/2, size/2, size/2);
            g.fillStyle(0xffa500); g.fillCircle(size/2, size/2, size/3);
            g.fillStyle(0xffff00); g.fillRect(size/2 - 3, size/2 - 3, 6, 6);
            g.generateTexture(key, size, size); g.destroy();
            return key;
        }

        function createEnemyTexture(scene) {
            const key = 'enemyTexture';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 32, height: 32 }, false);
            g.fillStyle(0x8B4513); g.fillEllipse(16, 17, 32, 28);
            g.fillStyle(0xffffff); g.fillEllipse(10, 12, 8, 10); g.fillEllipse(22, 12, 8, 10);
            g.fillStyle(0x000000); g.fillCircle(10, 12, 3); g.fillCircle(22, 12, 3);
            g.fillStyle(0xff0000); g.fillRect(8, 22, 16, 3);
            g.generateTexture(key, 32, 32); g.destroy();
            return key;
        }

        function createBrickTexture(scene, width, height) {
            const key = `brickTexture${width}x${height}`;
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width, height }, false);
            g.fillStyle(0xBF573B); // Reddish-brown
            g.fillRect(0, 0, width, height);
            g.lineStyle(3, 0x8C432E); // Darker brown for lines
            g.strokeRect(1.5, 1.5, width - 3, height - 3); // Inset border
            g.lineBetween(0, height / 2, width, height / 2);
            if (width > height * 1.5) {
                g.lineBetween(width / 2, 0, width / 2, height);
            }
            g.generateTexture(key, width, height);
            g.destroy();
            return key;
        }

        function createQuestionBlockTexture(scene) {
            const key = 'qBlock';
            if (scene.textures.exists(key)) return key;
            const rt = scene.make.renderTexture({ width: 40, height: 40 }, false);
            const g = scene.make.graphics({ add: false });
            g.fillStyle(0xf39c12); g.fillRect(0, 0, 40, 40);
            g.lineStyle(3, 0xffaa00); g.strokeRect(2, 2, 36, 36);
            rt.draw(g); g.destroy();
            const text = scene.make.text({ x: 12, y: 8, text: '?', style: { font: '24px "Press Start 2P"', fill: '#ffffff' }, add: false });
            rt.draw(text); text.destroy();
            rt.saveTexture(key);
            return key;
        }

        function createStarTexture(scene) {
            const key = 'star';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 32, height: 32 }, false);
            g.fillStyle(0xf1c40f);
            const points = [];
            const centerX = 16, centerY = 16, outerRadius = 15, innerRadius = 7;
            let angle = -Math.PI / 2;
            const angleStep = Math.PI / 5;
            for (let i = 0; i < 10; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                points.push(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
                angle += angleStep;
            }
            g.fillPoints(points, true);
            g.fillStyle(0x000000); g.fillCircle(11, 13, 2); g.fillCircle(21, 13, 2);
            g.generateTexture(key, 32, 32); g.destroy();
            return key;
        }

        function createWingTexture(scene) {
            const key = 'wing';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 32, height: 32 }, false);
            g.fillStyle(0xecf0f1);
            g.beginPath(); g.moveTo(16, 4); g.lineTo(4, 16); g.lineTo(16, 28); g.lineTo(28, 16); g.closePath();
            g.fillPath();
            g.lineStyle(2, 0xbdc3c7); g.strokePath();
            g.generateTexture(key, 32, 32); g.destroy();
            return key;
        }
        
        function createFireFlowerTexture(scene) {
            const key = 'fireFlower';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 32, height: 32 }, false);
            g.fillStyle(0x2ecc71); g.fillRect(12, 20, 8, 12); // Stem
            g.fillStyle(0xe67e22); g.fillCircle(16, 12, 12); // Petals (orange)
            g.fillStyle(0xf1c40f); g.fillCircle(16, 12, 6); // Center (yellow)
            g.fillStyle(0xffffff); g.fillCircle(12, 10, 3); g.fillCircle(20, 10, 3); // Eyes
            g.fillStyle(0x000000); g.fillCircle(12, 10, 1.5); g.fillCircle(20, 10, 1.5);
            g.generateTexture(key, 32, 32); g.destroy();
            return key;
        }

        function createFireballTexture(scene) {
            const key = 'fireball';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 16, height: 16 }, false);
            g.fillStyle(0xff4500); g.fillCircle(8, 8, 8);
            g.fillStyle(0xffa500); g.fillCircle(8, 8, 5);
            g.fillStyle(0xffff00); g.fillCircle(8, 8, 2);
            g.generateTexture(key, 16, 16); g.destroy();
            return key;
        }

        function createSpikeTexture(scene) {
            const key = 'spike';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 30, height: 30 }, false);
            g.fillStyle(0xc0392b); g.fillTriangle(15, 0, 0, 30, 30, 30);
            g.lineStyle(2, 0x8b0000); g.strokeTriangle(15, 0, 0, 30, 30, 30);
            g.generateTexture(key, 30, 30); g.destroy();
            return key;
        }

        function createSpringTexture(scene) {
            const key = 'spring';
            if (scene.textures.exists(key)) return key;
            const g = scene.make.graphics({ width: 40, height: 30 }, false);
            g.fillStyle(0x3498db); g.fillRect(0, 20, 40, 10);
            g.fillStyle(0x2980b9);
            for (let i = 0; i < 5; i++) {
                g.fillRect(i * 8, 10 + (i % 2) * 5, 8, 10);
            }
            g.generateTexture(key, 40, 30); g.destroy();
            return key;
        }
    </script>
</body>
</html>

